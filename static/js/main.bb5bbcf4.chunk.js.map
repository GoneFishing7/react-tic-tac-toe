{"version":3,"sources":["components/general_components/FakeTypedHeader.tsx","components/game_components/Square.tsx","components/game_components/Board.tsx","components/game_components/BoardHelpers.ts","components/game_components/AI.ts","components/general_components/Button.tsx","components/game_components/Game.tsx","components/settings_components/ButtonGroup.tsx","components/settings_components/Settings.tsx","components/Window.tsx","index.tsx"],"names":["FakeTypedHeader","props","state","toType","content","typed","currentTime","i","length","newWaitingTime","Math","random","setTimeout","setState","oldState","slice","className","this","React","Component","Square","onClick","clickHandler","isMidVert","symbol","Board","rowIndex","cellIndex","square","squares","handleClick","key","map","row","cell","renderSquare","BoardHelpers","symbols","Object","keys","symbolKey","colIndex","blanks","push","arr","floor","move","newArray","returnString","j","AI","blankSquares","getBlankSquares","randFromArr","getMove","mode","findBestMove","findRandomMove","getEmotion","turn","boardState","evaluateSquares","minimaxEval","evaluateSquaresMinimax","basicEval","maxDepth","Infinity","possibleMoves","bestMoves","bestScore","squaresWithMove","copyWithMove","moveEval","randBestMove","currentDepth","currentBoardState","currentPlayer","bestEval","boardWithMove","boardWithMoveEval","Button","classes","color","largeButton","roundedLeft","roundedRight","roundedNone","staticOnHover","position","join","children","Game","AiTurnCheck","isFinished","winner","makeAiMove","updateAiEmotion","settings","emotion","isP1sTurn","AiEmotion","prevState","comMove","newSquares","reset","Array","fill","ply1","ply2","ButtonGroup","htmlFor","id","label","Settings","DEFAULT_SETTINGS","selectDefaultSettings","newState","entries","forEach","settingId","defaultSetting","undefined","buttonGroups","buttons","isSelected","console","log","submit","toSubmit","settingData","selectedOption","find","buttonId","submitWithSettings","getButtonGroups","index","buttonGroupId","buttonGroupData","labelText","buttonData","logSelect","text","toSetTo","whoIsO","whoIsMovingFirst","rnd","playerTwoMode","esy","med","imp","hum","Window","toggleDarkMode","nextColorMode","colorMode","submitWithOptions","showSettings","showGame","cM","localStorage","getItem","setItem","role","aria-label","ReactDOM","render","document","getElementById"],"mappings":"8PA4CeA,E,kDAjCX,WAAYC,GAAyB,IAAD,uBAChC,cAAMA,IACDC,MAAQ,CACTC,OAAQF,EAAMG,QACdC,MAAO,IAGX,IADA,IAAIC,EAAc,IACTC,EAAI,EAAGA,EAAI,EAAKL,MAAMC,OAAOK,OAAQD,IAAK,CAC/C,IAAIE,EAAiC,IAAhBC,KAAKC,SAC1BC,YAAW,WACP,EAAKC,UAAS,SAACC,GACX,MAAO,CACHX,OAAQW,EAASX,OAAOY,MACpB,EACAD,EAASX,OAAOK,QAEpBH,MAAOS,EAAST,MAAQS,EAASX,OAAOY,MAAM,EAAG,SAG1DT,EAAcG,GACjBH,GAAeG,EApBa,S,qDAwBhC,OACI,wBAAIO,UAAU,qBAAd,IACSC,KAAKf,MAAMG,MAChB,0BAAMW,UAAU,yBAAhB,U,GA5BcE,IAAMC,W,OCarBC,E,uKAbP,OACI,wBACIC,QAASJ,KAAKhB,MAAMqB,aACpBN,UACI,QAAUC,KAAKhB,MAAMsB,UAAY,eAAiB,KAGrDN,KAAKhB,MAAMuB,Y,GATPN,IAAMC,WCwCZM,E,2KAvCEC,EAAkBC,GAAoB,IAAD,OACxCC,EAASX,KAAKhB,MAAM4B,QAAQH,GAAUC,GAC5C,OACI,kBAAC,EAAD,CACIH,OAAQI,EACRN,aAAc,WACV,EAAKrB,MAAM6B,YAAYJ,EAAUC,IAErCJ,UAAyB,IAAdI,EACXI,IAAKJ,EAAY,KAAOD,M,+BAK1B,IAAD,OACL,OACI,2BAAOV,UAAU,SACb,+BACKC,KAAKhB,MAAM4B,QAAQG,KAAI,SAACC,EAAeP,GACpC,OACI,wBACIK,IAAKL,EACLV,UAAwB,IAAbU,EAAiB,aAAe,IAE1CO,EAAID,KAAI,SAACE,EAAcP,GACpB,OAAO,EAAKQ,aACRT,EACAC,gB,GA5BpBT,IAAMC,W,OCmJXiB,E,6GA9IPP,EACAQ,GAEA,cAAwBC,OAAOC,KAAKF,GAApC,eAA8C,CAAzC,IAAyC,EAAnCG,EAAS,KACVhB,EAASa,EAAQG,GADmB,cAG1BX,GAH0B,IAG1C,2BAAyB,CAAC,IAAjBI,EAAgB,QACrB,GACIA,EAAI,KAAOT,GACXS,EAAI,KAAOT,GACXS,EAAI,KAAOT,EAEX,OAAOgB,GAT2B,8BAa1C,IAAK,IAAIC,EAAW,EAAGA,EAAWZ,EAAQrB,OAAQiC,IAC9C,GACIZ,EAAQ,GAAGY,KAAcjB,GACzBK,EAAQ,GAAGY,KAAcjB,GACzBK,EAAQ,GAAGY,KAAcjB,EAEzB,OAAOgB,EAIf,GACIX,EAAQ,GAAG,KAAOL,GAClBK,EAAQ,GAAG,KAAOL,GAClBK,EAAQ,GAAG,KAAOL,EAElB,OAAOgB,EAEX,GACIX,EAAQ,GAAG,KAAOL,GAClBK,EAAQ,GAAG,KAAOL,GAClBK,EAAQ,GAAG,KAAOL,EAElB,OAAOgB,EAGf,OAAO,O,sCAWYX,GAEnB,IADA,IAAIa,EAAS,GACJhB,EAAW,EAAGA,EAAWG,EAAQrB,OAAQkB,IAC9C,IACI,IAAIC,EAAY,EAChBA,EAAYE,EAAQH,GAAUlB,OAC9BmB,IAEKE,EAAQH,GAAUC,IACnBe,EAAOC,KAAK,CACRV,IAAKP,EACLQ,KAAMP,IAKtB,OAAOe,I,kCAWQE,GACf,OAAOA,EAAIlC,KAAKmC,MAAMnC,KAAKC,SAAWiC,EAAIpC,W,mCAc1CoC,EACApB,EACAsB,GAGA,IADA,IAAIC,EAAW,GACNxC,EAAI,EAAGA,EAAIqC,EAAIpC,OAAQD,IAC5BwC,EAASJ,KAAKC,EAAIrC,GAAGQ,SAKzB,OAHIS,GAAUsB,IACVC,EAASD,EAAKb,KAAKa,EAAKZ,MAAQV,GAE7BuB,I,oCAWUlB,GAcjB,IAbA,IACImB,EAAe,qCAYVzC,EAAI,EAAGA,EAAIsB,EAAQrB,OAAQD,IAAK,CACrCyC,GAAgBzC,EAAI,EAAI,KACxB,IAAK,IAAI0C,EAAI,EAAGA,EAAIpB,EAAQtB,GAAGC,OAAQyC,IACnCD,GACI,KAAOnB,EAAQtB,GAAG0C,GAAKpB,EAAQtB,GAAG0C,GAAK,KAAO,KAEtDD,GAAgB,sBAEpB,OAAOA,M,KC/ITE,E,4GAoMoBrB,GAClB,IAAMsB,EAAef,EAAagB,gBAAgBvB,GAClD,OAAOO,EAAaiB,YAAYF,O,KAtMlCD,EAWKI,QAAU,SACbzB,EACA0B,EACAlB,GAGA,OAAKD,EAAagB,gBAAgBvB,GAASrB,QAS7B,QAAT+C,EAAkB,SAAC1B,EAAqBQ,GAAuB,OAAOa,EAAGM,aAAa3B,EAASQ,EAhC9E,IAiCR,QAATkB,EAAkBL,EAAGM,aACtBN,EAAGO,gBACa5B,EAASQ,GAXlB,CACHJ,KAAM,EACNC,MAAO,IApBjBgB,EA2CKQ,WAAa,SAChB7B,EACA0B,EACAI,EACAtB,GAGA,IAAIuB,EAAaxB,EAAayB,gBAAgBhC,EAASQ,GACvD,GAAIuB,EACA,MAAmB,SAAfA,EACO,6DAEA,6BAIf,GAAqD,IAAjDxB,EAAagB,gBAAgBvB,GAASrB,OACtC,MAAO,yBAGX,GAAa,QAAT+C,EAAgB,CAChB,IAAIO,EAAcZ,EAAGa,uBACjBlC,EACS,SAAT8B,GAAmB,EAAI,EACvBtB,GAEJ,OAAoB,IAAhByB,EACO,kBACgB,IAAhBA,EACA,uBAEA,iCAER,GAAa,QAATP,EAAgB,CACvB,IAAIS,EAAYd,EAAGa,uBACflC,EACS,SAAT8B,GAAmB,EAAI,EACvBtB,EAtFc,GAyFlB,OAAkB,IAAd2B,EACO,kCACc,IAAdA,EACA,iDAEA,mDAER,MAAa,QAATT,EACA,2CAEJ,0BA7FTL,EAgGKM,aAAe,SAClB3B,EACAQ,GAEU,IAAD,EADT4B,EACS,uDADEC,IAGPC,EAAgB/B,EAAagB,gBAAgBvB,GAC7CuC,EAAsB,GACtBC,GAAa,EAJR,cAKUF,GALV,IAKT,2BAAkC,CAAC,IAAxBrB,EAAuB,QAC1BwB,EAAkBlC,EAAamC,aAC/B1C,EACAQ,EAAO,KACPS,GAEA0B,GAAYtB,EAAGa,uBACfO,GACC,EACDjC,EACA4B,GAEAO,EAAWH,GACXA,EAAYG,EACZJ,EAAY,CAACtB,IACN0B,IAAaH,GACpBD,EAAUzB,KAAKG,IArBd,8BAwBT,IAAI2B,EAAerC,EAAaiB,YAAYe,GAC5C,OAAOK,GA7HTvB,EA6IKa,uBAAyB,SAC5BlC,EACA8B,EACAtB,GAGU,IAFV4B,EAES,uDAFEC,IACXQ,EACS,uDADM,EAEf,GAAIA,GAAgBT,EAChB,OAAQ,EAGZ,IAAIU,EAAoBvC,EAAayB,gBAAgBhC,EAASQ,GAC9D,GAAIsC,EACA,OAA8B,SAAtBA,GAAgC,EAAI,GAAKhB,EAGrD,IAVS,EAULiB,EAAyB,IAATjB,EAAa,OAAS,OAEtCQ,EAAgB/B,EAAagB,gBAAgBvB,GAC7CgD,GAAY,EAbP,cAcUV,GAdV,IAcT,2BAAkC,CAAC,IAAxBrB,EAAuB,QAC1BgC,EAAgB1C,EAAamC,aAC7B1C,EACAQ,EAAQuC,GACR9B,GAEAiC,GAAqB7B,EAAGa,uBACxBe,GACCnB,EACDtB,EACA4B,EACAS,EAAe,GAEO,OAAtBK,IAGAA,EAAoBF,IACpBA,EAAWE,KA/BV,8BAkCT,OAA6B,IAAzBZ,EAAc3D,OACP,EAEJqE,GAkBA3B,QChKA8B,E,uKAnCP,IAAMC,EAAU,CAAC,UAwBjB,OAvBIhE,KAAKhB,MAAMiF,MACXD,EAAQtC,KAAK,UAAY1B,KAAKhB,MAAMiF,OAEpCD,EAAQtC,KAAK,eAEb1B,KAAKhB,MAAMkF,aACXF,EAAQtC,KAAK,gBAEb1B,KAAKhB,MAAMmF,aACXH,EAAQtC,KAAK,uBAEb1B,KAAKhB,MAAMoF,cACXJ,EAAQtC,KAAK,wBAEb1B,KAAKhB,MAAMqF,aACXL,EAAQtC,KAAK,uBAEb1B,KAAKhB,MAAMsF,eACXN,EAAQtC,KAAK,iBAEb1B,KAAKhB,MAAMuF,UACXP,EAAQtC,KAAK1B,KAAKhB,MAAMuF,UAGxB,4BACInE,QAASJ,KAAKhB,MAAM6B,YACpBd,UAAWiE,EAAQQ,KAAK,MAEvBxE,KAAKhB,MAAMyF,c,GA/BPxE,IAAMC,WCmMZwE,E,kDA3LX,WAAY1F,GAAyB,IAAD,8BAChC,cAAMA,IAqEV2F,YAAc,WAEV,IAAK,EAAK1F,MAAM2F,WAAY,CAExB,IAAIC,EAAS1D,EAAayB,gBACtB,EAAK3D,MAAM2B,QACX,EAAK3B,MAAMmC,SAEf,GAAIyD,EAKA,YAJA,EAAKjF,SAAS,CACVgF,YAAY,EACZC,OAAQA,IAKhB,GAAgE,IAA5D1D,EAAagB,gBAAgB,EAAKlD,MAAM2B,SAASrB,OAKjD,YAJA,EAAKK,SAAS,CACVgF,YAAY,EACZC,OAAQ,SAIhB,EAAKC,eA7FuB,EAiGpCC,gBAAkB,WAEd,GAA6C,QAAzC,EAAK/F,MAAMgG,SAAX,cAAJ,CAGA,IAAIC,EAAUhD,EAAGQ,WACb,EAAKxD,MAAM2B,QACX,EAAK5B,MAAMgG,SAAX,cACA,EAAK/F,MAAMiG,UAAY,OAAS,OAChC,EAAKjG,MAAMmC,SAEX,EAAKnC,MAAMkG,YAAcF,GAG7B,EAAKrF,SAAS,CACVuF,UAAWF,MAhHiB,EAoHpCH,WAAa,WAEJ,EAAK7F,MAAMiG,WAC6B,QAAzC,EAAKlG,MAAMgG,SAAX,eAEA,EAAKpF,UAAS,SAACwF,GACX,IAAIC,EAAUpD,EAAGI,QACb,EAAKpD,MAAM2B,QACX,EAAK5B,MAAMgG,SAAX,cACA,EAAK/F,MAAMmC,SAEXkE,EAAanE,EAAamC,aAC1B,EAAKrE,MAAM2B,QACX,EAAK3B,MAAMmC,QAAX,KACAiE,GAOJ,OALY,2BACLD,GADK,IAERxE,QAAS0E,EACTJ,WAAW,QAvIS,EA8IpCK,MAAQ,WACJ,EAAK3F,SAAS,CACVuF,UAAW,KACXP,YAAY,EACZM,UACgD,QAA5C,EAAKlG,MAAMgG,SAAX,iBACMvF,KAAKC,UAAY,GAC2B,SAA5C,EAAKV,MAAMgG,SAAX,iBACVpE,QAAS4E,MAAM,GAAGC,KAAKD,MAAM,GAAGC,KAAK,OACrCrE,QAAS,CACLsE,KAAwC,SAAlC,EAAK1G,MAAMgG,SAAX,OAA2C,IAAM,IACvDW,KAAwC,SAAlC,EAAK3G,MAAMgG,SAAX,OAA2C,IAAM,KAE3DH,OAAQ,QA3JoB,EA+JpChE,YAAc,SAACJ,EAAkBC,GAE7B,IAAI,EAAKzB,MAAM2F,aAIX,EAAK3F,MAAM2B,QAAQH,GAAUC,KAK5B,EAAKzB,MAAMiG,WAC6B,QAAzC,EAAKlG,MAAMgG,SAAX,eAFJ,CAOA,IAAIpE,EAAUO,EAAamC,aAAa,EAAKrE,MAAM2B,SACnDA,EAAQH,GAAUC,GAAa,EAAKzB,MAAMmC,QACtC,EAAKnC,MAAMiG,UAAY,OAAS,QAEpC,EAAKtF,SAAS,CACVgB,QAASA,EACTsE,WAAY,EAAKjG,MAAMiG,cApL3B,EAAKjG,MAAQ,CACTiG,UAC2C,QAAvClG,EAAMgG,SAAN,iBACMvF,KAAKC,UAAY,GACsB,SAAvCV,EAAMgG,SAAN,iBACV5D,QAAS,CACLsE,KAAmC,SAA7B1G,EAAMgG,SAAN,OAAsC,IAAM,IAClDW,KAAmC,SAA7B3G,EAAMgG,SAAN,OAAsC,IAAM,KAEtDJ,YAAY,EACZhE,QAAS4E,MAAM,GAAGC,KAAKD,MAAM,GAAGC,KAAK,OAMrCZ,OAAQ,KACRM,UAAW,MAnBiB,E,qDAuB1B,IAAD,OACL,OACI,6BACI,4BAC2B,SAAtBnF,KAAKf,MAAM4F,OACN,QACA7E,KAAKf,MAAM4F,OAAX,UACG7E,KAAKf,MAAM4F,OADd,UAEA,IAEV,kBAAC,EAAD,CACIjE,QAASZ,KAAKf,MAAM2B,QACpBC,YAAab,KAAKa,cAEtB,2CACkB,IACbb,KAAKf,MAAMiG,UAAY,WAAa,WAFzC,KAGKlF,KAAKf,MAAMmC,QAAQpB,KAAKf,MAAMiG,UAAY,OAAS,QAHxD,KAMA,kBAAC,EAAD,CACIjB,MAAM,SACNpD,YAAa,WACT,EAAK0E,UAHb,eAQ0C,QAAzCvF,KAAKhB,MAAMgG,SAAX,cACG,kCAAQhF,KAAKf,MAAMkG,WAAa,kCAEhC,M,0CAOZnF,KAAK2E,cACL3E,KAAK+E,oB,2CAIL/E,KAAK2E,cACL3E,KAAK+E,sB,GApEM9E,IAAMC,W,OCDV0F,E,uKATP,OACI,yBAAK7F,UAAU,gBACX,2BAAO8F,QAAS7F,KAAKhB,MAAM8G,IAAK9F,KAAKhB,MAAM+G,OAC3C,yBAAKD,GAAI9F,KAAKhB,MAAM8G,IAAK9F,KAAKhB,MAAMyF,e,GAL1BxE,IAAMC,WCsMjB8F,E,kDAnLX,WAAYhH,GAAyB,IAAD,8BAChC,cAAMA,IAHViH,iBAA6C,GAET,EA+DpCC,sBAAwB,WACpB,EAAKtG,UAAS,SAACC,GACX,IAAIsG,EAAQ,eAAQtG,GAkBpB,OAjBAwB,OAAO+E,QAAQ,EAAKH,kBAAkBI,SAClC,YAAkC,IAAD,mBAA/BC,EAA+B,KAApBC,EAAoB,UACYC,IAArCL,EAASM,aAAaH,GAI1BH,EAASM,aAAaH,GAAWI,QAC7BH,GACFI,YAAa,EALXC,QAAQC,IAAI,YAQxBxF,OAAOC,KAAKzB,EAAS4G,cAAcJ,SAAQ,SAACC,GACxCH,EAASM,aAAaH,GAAWI,QAC7B,EAAKT,iBAAiBK,IAClBjF,OAAOC,KAAK6E,EAASM,aAAaH,GAAWI,SAAS,IAC5DC,YAAa,KAEZR,MAnFqB,EA4GpCW,OAAS,WACL,IAAIC,EAAoD,GACxD1F,OAAO+E,QAAQ,EAAKnH,MAAMwH,cAAcJ,SACpC,YAA+B,IAAD,mBAA5BC,EAA4B,KAAjBU,EAAiB,KACtBC,EAAiB5F,OAAOC,KAAK0F,EAAYN,SAASQ,MAClD,SAACC,GAAD,OAAcH,EAAYN,QAAQS,GAAUR,cAEhDI,EAAST,GAAa,SAAWW,KAGzC,EAAKjI,MAAMoI,mBAAmBL,IAtHE,EAyHpCM,gBAAkB,WACd,OACI,yBAAKtH,UAAU,iBACVsB,OAAO+E,QAAQ,EAAKnH,MAAMwH,cAAc1F,KACrC,WAAmCuG,GAAW,IAAD,mBAA3CC,EAA2C,KAA5BC,EAA4B,KACzC,OACI,kBAAC,EAAD,CACI1B,GAAIyB,EACJxB,MAAOyB,EAAgBC,UACvB3G,IAAKwG,GAEJjG,OAAO+E,QAAQoB,EAAgBd,SAAS3F,KACrC,WAAyBuG,GAAW,IAAD,mBAAjCH,EAAiC,KAAvBO,EAAuB,KAC/B,OACI,kBAAC,EAAD,CACI7G,YAAa,WACT,EAAK8G,UACDJ,EACAJ,IAGRlD,MACIyD,EAAWf,WACL,gBACA,OAEV7F,IAAKwG,EACLhD,cACIoD,EAAWf,YAGde,EAAWE,eAxJpB,EAqKpCD,UAAY,SAACrB,EAAmBuB,GAC5B,EAAKjI,UAAS,SAACC,GACX,IAAIsG,EAAQ,eAAQtG,GAOpB,OANAwB,OAAO+E,QAAQD,EAASM,aAAaH,GAAWI,SAASL,SACrD,YAAiB,IAAD,6BACPM,YAAa,KAG1BR,EAASM,aAAaH,GAAWI,QAAQmB,GAASlB,YAAa,EACxDR,MA5KX,EAAKlH,MAAQ,CACTwH,aAAc,CACVqB,OAAQ,CACJL,UAAW,YACXf,QAAS,CACLhB,KAAM,CACFiB,YAAY,EACZiB,KAAM,YAEVjC,KAAM,CACFgB,YAAY,EACZiB,KAAM,cAIlBG,iBAAkB,CACdN,UAAW,uBACXf,QAAS,CACLsB,IAAK,CACDrB,YAAY,EACZiB,KAAM,UAEVlC,KAAM,CACFiB,YAAY,EACZiB,KAAM,YAEVjC,KAAM,CACFgB,YAAY,EACZiB,KAAM,cAIlBK,cAAe,CACXR,UAAW,iBACXf,QAAS,CACLwB,IAAK,CACDvB,YAAY,EACZiB,KAAM,iBAEVO,IAAK,CACDxB,YAAY,EACZiB,KAAM,mBAEVQ,IAAK,CACDzB,YAAY,EACZiB,KAAM,uBAEVS,IAAK,CACD1B,YAAY,EACZiB,KAAM,aAnDM,E,gEA4DhC5H,KAAKkG,0B,+BA2BC,IAAD,OACL,OACI,yBAAKnG,UAAU,YACX,wCAECC,KAAKqH,kBAGN,kBAAC,EAAD,CACIxG,YAAa,WACT,EAAKiG,UAET7C,MAAM,eACNC,aAAa,GALjB,c,GAlGOjE,IAAMC,WCkEdoI,E,kDAzEX,WAAYtJ,GAAsB,IAAD,uBAC7B,cAAMA,IAuDVuJ,eAAiB,WACb,IAAIC,EACyB,UAAzB,EAAKvJ,MAAMwJ,UAAwB,OAAS,QAChD,EAAK7I,SAAS,CACV6I,UAAWD,KA5Dc,EAgEjCE,kBAAoB,SAAC1D,GACjB,EAAKpF,SAAS,CACV+I,cAAc,EACdC,UAAU,EACV5D,SAAUA,KAhEd,IAAI6D,EAAwBC,aAAaC,QAAQ,aAJpB,OAKxBF,IACDC,aAAaE,QAAQ,YAAa,SAClCH,EAAK,SAGT,EAAK5J,MAAQ,CACT0J,cAAc,EACdC,UAAU,EACV5D,SAAU,CACN8C,OAAQ,KACRC,iBAAkB,KAClBE,cAAe,MAEnBQ,UAAWI,GAlBc,E,qDAsBvB,IAAD,OACL,OACI,yBAAK9I,UAAS,iBAAYC,KAAKf,MAAMwJ,YACjC,kBAAC,EAAD,CAAiBtJ,QAAQ,gBACzB,wBAAIY,UAAU,YACbC,KAAKf,MAAM0J,cACR,kBAAC,EAAD,CAASvB,mBAAoBpH,KAAK0I,oBAErC1I,KAAKf,MAAM2J,UAAY,kBAAC,EAAD,CAAM5D,SAAUhF,KAAKf,MAAM+F,WACnD,kBAAC,EAAD,CACIf,MAC6B,UAAzBjE,KAAKf,MAAMwJ,UACL,cACA,eAEV5H,YAAa,WACT,EAAK0H,kBAEThE,SAAS,MATb,aAWe,IACX,0BAAM0E,KAAK,MAAMC,aAAW,SAA5B,oB,2CAUZJ,aAAaE,QAAQ,YAAahJ,KAAKf,MAAMwJ,e,GAtDhCxI,IAAMC,W,MCT3BiJ,IAASC,OAAO,kBAAC,EAAD,MAAYC,SAASC,eAAe,W","file":"static/js/main.bb5bbcf4.chunk.js","sourcesContent":["import React from \"react\";\n\ninterface Props {\n    content: string;\n}\ninterface State {\n    toType: string;\n    typed: string;\n}\n\nclass FakeTypedHeader extends React.Component<Props, State> {\n    constructor(props: Readonly<Props>) {\n        super(props);\n        this.state = {\n            toType: props.content,\n            typed: \"\",\n        };\n        let currentTime = 100;\n        for (let i = 0; i < this.state.toType.length; i++) {\n            let newWaitingTime = Math.random() * 200;\n            setTimeout(() => {\n                this.setState((oldState) => {\n                    return {\n                        toType: oldState.toType.slice(\n                            1,\n                            oldState.toType.length\n                        ),\n                        typed: oldState.typed + oldState.toType.slice(0, 1),\n                    };\n                });\n            }, currentTime + newWaitingTime);\n            currentTime += newWaitingTime;\n        }\n    }\n    render() {\n        return (\n            <h1 className=\"fake-typed-header\">\n                &gt;{this.state.typed}\n                <span className=\"blinking unselectable\">_</span>\n            </h1>\n        );\n    }\n}\n\nexport default FakeTypedHeader;\n","import React from \"react\";\n\ninterface Props {\n    clickHandler: () => void,\n    symbol: string,\n    isMidVert: boolean\n}\n\nclass Square extends React.Component<Props> {\n    render() {\n        return (\n            <td\n                onClick={this.props.clickHandler}\n                className={\n                    \"cell\" + (this.props.isMidVert ? \" middle-vert\" : \"\")\n                }\n            >\n                {this.props.symbol}\n            </td>\n        );\n    }\n}\n\nexport default Square;\n","import React from \"react\";\nimport Square from \"./Square\";\n\ninterface Props {\n    squares: string[][],\n    handleClick: (rowIndex: number, cellIndex: number) => void,\n}\n\nclass Board extends React.Component<Props> {\n    renderSquare(rowIndex: number, cellIndex: number) {\n        const square = this.props.squares[rowIndex][cellIndex];\n        return (\n            <Square\n                symbol={square}\n                clickHandler={() => {\n                    this.props.handleClick(rowIndex, cellIndex);\n                }}\n                isMidVert={cellIndex === 1}\n                key={cellIndex + \", \" + rowIndex}\n            />\n        );\n    }\n\n    render() {\n        return (\n            <table className=\"board\">\n                <tbody>\n                    {this.props.squares.map((row: string[], rowIndex: number) => {\n                        return (\n                            <tr\n                                key={rowIndex}\n                                className={rowIndex === 1 ? \"middle-row\" : \"\"}\n                            >\n                                {row.map((cell: string, cellIndex: number) => {\n                                    return this.renderSquare(\n                                        rowIndex,\n                                        cellIndex\n                                    );\n                                })}\n                            </tr>\n                        );\n                    })}\n                </tbody>\n            </table>\n        );\n    }\n}\n\nexport default Board;\n","import { Symbols, Square } from \"../general_components/Types\";\n\nclass BoardHelpers {\n    /**\n     * Evaluate squares passed in\n     *\n     * @static\n     * @param squares The squares to evaluate\n     * @param symbols The symbols to check for, eg. {ply1: X,ply2: O}\n     * @returns The winning player, else null\n     * @memberof BoardHelpers\n     */\n    static evaluateSquares(\n        squares: string[][],\n        symbols: Symbols\n    ): string | null {\n        for (const symbolKey of Object.keys(symbols)) {\n            const symbol = symbols[symbolKey];\n            // Check horizontals\n            for (let row of squares) {\n                if (\n                    row[0] === symbol &&\n                    row[1] === symbol &&\n                    row[2] === symbol\n                ) {\n                    return symbolKey;\n                }\n            }\n            // Check verticals\n            for (let colIndex = 0; colIndex < squares.length; colIndex++) {\n                if (\n                    squares[0][colIndex] === symbol &&\n                    squares[1][colIndex] === symbol &&\n                    squares[2][colIndex] === symbol\n                ) {\n                    return symbolKey;\n                }\n            }\n            // Check diagonals\n            if (\n                squares[0][0] === symbol &&\n                squares[1][1] === symbol &&\n                squares[2][2] === symbol\n            ) {\n                return symbolKey;\n            }\n            if (\n                squares[0][2] === symbol &&\n                squares[1][1] === symbol &&\n                squares[2][0] === symbol\n            ) {\n                return symbolKey;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get all the blank squares of the board (squares that are null or have a falsy value)\n     *\n     * @static\n     * @param squares The squares to check\n     * @returns The squares found, in form {row: x, col: y}\n     * @memberof BoardHelpers\n     */\n    static getBlankSquares(squares: string[][]): Square[] {\n        let blanks = [];\n        for (let rowIndex = 0; rowIndex < squares.length; rowIndex++) {\n            for (\n                let cellIndex = 0;\n                cellIndex < squares[rowIndex].length;\n                cellIndex++\n            ) {\n                if (!squares[rowIndex][cellIndex]) {\n                    blanks.push({\n                        row: rowIndex,\n                        cell: cellIndex,\n                    });\n                }\n            }\n        }\n        return blanks;\n    }\n\n    /**\n     * Returns a random element from an array\n     *\n     * @static\n     * @param arr The array to find an element from\n     * @returns A random element\n     * @memberof BoardHelpers\n     */\n    static randFromArr(arr: Array<any>): any {\n        return arr[Math.floor(Math.random() * arr.length)];\n    }\n\n    /**\n     * Deep copies a Two-Dimensional Array of Squares with a move\n     *\n     * @static\n     * @param arr The 2D array of squares\n     * @param symbol The symbol of the move\n     * @param move The position of the move, in form {row: x, cel: y}\n     * @returns A new 2D array of squares with the move applied\n     * @memberof BoardHelpers\n     */\n    static copyWithMove(\n        arr: string[][],\n        symbol?: string,\n        move?: Square\n    ): string[][] {\n        let newArray = [];\n        for (let i = 0; i < arr.length; i++) {\n            newArray.push(arr[i].slice());\n        }\n        if (symbol && move) {\n            newArray[move.row][move.cell] = symbol;\n        }\n        return newArray;\n    }\n\n    /**\n     * Takes the board and converts it to a nice string\n     *\n     * @static\n     * @param squares The board\n     * @returns The board to string\n     * @memberof BoardHelpers\n     */\n    static boardToString(squares: string[][]): string {\n        let horizontalLine = \"-------------\\n\";\n        let returnString = \"\\n    1   2   3\\n  \" + horizontalLine;\n        /*\n         *     1   2   3\n         *   -------------\n         * 1 | - | - | - |\n         *   -------------\n         * 2 | - | - | - |\n         *   -------------\n         * 3 | - | - | - |\n         *   -------------\n         *\n         */\n        for (let i = 0; i < squares.length; i++) {\n            returnString += i + 1 + \" |\";\n            for (let j = 0; j < squares[i].length; j++) {\n                returnString +=\n                    \" \" + (squares[i][j] ? squares[i][j] : \" \") + \" |\";\n            }\n            returnString += \"\\n  \" + horizontalLine;\n        }\n        return returnString;\n    }\n}\n\nexport default BoardHelpers;\n","import BoardHelpers from \"./BoardHelpers\";\nimport { Symbols, Square } from \"../general_components/Types\";\nconst MEDIUM_COMPUTER_DEPTH = 2;\n\ninterface findMove {\n    (squares: string[][], symbols: Symbols): Square;\n}\n\nclass AI {\n    /**\n     * Returns a move from the AI based on the mode\n     *\n     * @method\n     * @static\n     * @param squares The board\n     * @param mode The mode\n     * @param symbols The symbols, eg. {ply1: X, ply2: O}\n     * @memberof AI\n     */\n    static getMove = (\n        squares: string[][],\n        mode: string | null | undefined,\n        symbols: Symbols\n    ): Square => {\n        // Make sure there are still blank squares\n        if (!BoardHelpers.getBlankSquares(squares).length) {\n            return {\n                row: -1,\n                cell: -1,\n            };\n        }\n        // Redirect to move generator based on mode inputted\n        // prettier-ignore\n        let moveFunction =\n            (mode === \"med\") ? (squares: string[][], symbols: Symbols) => { return AI.findBestMove(squares, symbols, MEDIUM_COMPUTER_DEPTH) } :\n            (mode === \"imp\") ? AI.findBestMove : \n            AI.findRandomMove\n        return moveFunction(squares, symbols);\n    };\n\n    /**\n     * Returns an kaomoji based on the computer's evaluation\n     *\n     * @method\n     * @static\n     * @param {string[][]} squares The board\n     * @param {\"esy\" | \"med\" | \"imp\"} mode The mode\n     * @param {\"ply1\"|\"ply2\"} turn Who's turn it is\n     * @param {Object} symbols The symbols, eg. {ply1: X, ply2: O}\n     * @memberof AI\n     */\n    static getEmotion = (\n        squares: string[][],\n        mode: string | null | undefined,\n        turn: \"ply1\" | \"ply2\",\n        symbols: Symbols\n    ): string => {\n        // Check for terminal state\n        let boardState = BoardHelpers.evaluateSquares(squares, symbols);\n        if (boardState) {\n            if (boardState === \"ply1\") {\n                return \"(‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ‚îª‚îÅ‚îª\";\n            } else {\n                return \"(‚úø‚ó†‚Äø‚ó†)\";\n            }\n        }\n        // Make sure there are still available squares\n        if (BoardHelpers.getBlankSquares(squares).length === 0) {\n            return \"·ïï( ·êõ )·ïó\";\n        }\n        // Give emotion based on com mode and evaluated state\n        if (mode === \"imp\") {\n            let minimaxEval = AI.evaluateSquaresMinimax(\n                squares,\n                turn === \"ply1\" ? -1 : 1,\n                symbols\n            );\n            if (minimaxEval === 1) {\n                return \"(‡≤†.‡≤†)\";\n            } else if (minimaxEval === 0) {\n                return \"(‚äôÀç‚äô)\";\n            } else {\n                return \"‚ï∞(*¬∞‚ñΩ¬∞*)‚ïØ\";\n            }\n        } else if (mode === \"med\") {\n            let basicEval = AI.evaluateSquaresMinimax(\n                squares,\n                turn === \"ply1\" ? -1 : 1,\n                symbols,\n                MEDIUM_COMPUTER_DEPTH\n            );\n            if (basicEval === 1) {\n                return \"(„Å£ ¬∞–î ¬∞;)„Å£\";\n            } else if (basicEval === 0) {\n                return \"‚îå‡ºº œÉ ‚Ä∏ œÉ ‡ºΩ‚îê\";\n            } else {\n                return \"ÔºàÔºæ‚àÄÔºæ‚óèÔºâÔæâÔΩº\";\n            }\n        } else if (mode === \"esy\") {\n            return \"‡ºº „Å§ ‚óï_‚óï ‡ºΩ„Å§\";\n        }\n        return \"w(Ôæü–îÔæü)w\";\n    };\n\n    static findBestMove = (\n        squares: string[][],\n        symbols: Symbols,\n        maxDepth = Infinity\n    ): Square => {\n        // debugger;\n        let possibleMoves = BoardHelpers.getBlankSquares(squares);\n        let bestMoves: Square[] = [];\n        let bestScore = -2;\n        for (const move of possibleMoves) {\n            let squaresWithMove = BoardHelpers.copyWithMove(\n                squares,\n                symbols[\"ply2\"],\n                move\n            );\n            let moveEval = -AI.evaluateSquaresMinimax(\n                squaresWithMove,\n                -1,\n                symbols,\n                maxDepth\n            );\n            if (moveEval > bestScore) {\n                bestScore = moveEval;\n                bestMoves = [move];\n            } else if (moveEval === bestScore) {\n                bestMoves.push(move);\n            }\n        }\n        let randBestMove = BoardHelpers.randFromArr(bestMoves);\n        return randBestMove;\n    };\n\n    /**\n     * Evaluate the board and future boards from the board with the minimax algorithm.\n     *\n     * @method\n     * @static\n     * @param squares The squares to evaluate.\n     * @param turn The turn 1 for com, -1 for player\n     * @param symbols The symbols, eg. [ply1: X, ply2: O]\n     * @param maxDepth THe maximum depth to analyze to.\n     * @param currentDepth THe depth currently analyzed to\n     * @returns 1 for com winning, -1 for player winning, 0 for equal. -2 for something went wrong\n     * @memberof AI\n     */\n    static evaluateSquaresMinimax = (\n        squares: string[][],\n        turn: number,\n        symbols: Symbols,\n        maxDepth = Infinity,\n        currentDepth = 0\n    ): number => {\n        if (currentDepth >= maxDepth) {\n            return -2;\n        }\n        // Check for terminal positions\n        let currentBoardState = BoardHelpers.evaluateSquares(squares, symbols);\n        if (currentBoardState) {\n            return (currentBoardState === \"ply1\" ? -1 : 1) * turn; // NOTE: Adjusted for minimizer\n        }\n        // Check current player\n        let currentPlayer = turn === 1 ? \"ply2\" : \"ply1\";\n        // Get blank squares\n        let possibleMoves = BoardHelpers.getBlankSquares(squares);\n        let bestEval = -2;\n        for (const move of possibleMoves) {\n            let boardWithMove = BoardHelpers.copyWithMove(\n                squares,\n                symbols[currentPlayer],\n                move\n            );\n            let boardWithMoveEval = -AI.evaluateSquaresMinimax(\n                boardWithMove,\n                -turn,\n                symbols,\n                maxDepth,\n                currentDepth + 1\n            );\n            if (boardWithMoveEval === null) {\n                continue;\n            }\n            if (boardWithMoveEval > bestEval) {\n                bestEval = boardWithMoveEval;\n            }\n        }\n        if (possibleMoves.length === 0) {\n            return 0;\n        }\n        return bestEval;\n    };\n\n    /**\n     * Returns a random move from the squares\n     *\n     * @method\n     * @static\n     * @param squares The squares\n     * @returns A random move in form {ply1: x, ply2: y}\n     * @memberof AI\n     */\n    static findRandomMove(squares: string[][]): Square {\n        const blankSquares = BoardHelpers.getBlankSquares(squares);\n        return BoardHelpers.randFromArr(blankSquares);\n    }\n}\n\nexport default AI;\n","import React from \"react\";\n\ninterface Props {\n    handleClick?: () => void;\n    color?: string;\n    largeButton?: boolean;\n    roundedLeft?: boolean;\n    roundedRight?: boolean;\n    roundedNone?: boolean;\n    staticOnHover?: boolean;\n    position?: string;\n}\n\nclass Button extends React.Component<Props> {\n    render() {\n        const classes = [\"button\"];\n        if (this.props.color) {\n            classes.push(\"button-\" + this.props.color);\n        } else {\n            classes.push(\"button-gray\");\n        }\n        if (this.props.largeButton) {\n            classes.push(\"button-large\");\n        }\n        if (this.props.roundedLeft) {\n            classes.push(\"button-rounded-left\");\n        }\n        if (this.props.roundedRight) {\n            classes.push(\"button-rounded-right\");\n        }\n        if (this.props.roundedNone) {\n            classes.push(\"button-rounded-none\");\n        }\n        if (this.props.staticOnHover) {\n            classes.push(\"button-static\");\n        }\n        if (this.props.position) {\n            classes.push(this.props.position);\n        }\n        return (\n            <button\n                onClick={this.props.handleClick}\n                className={classes.join(\" \")}\n            >\n                {this.props.children}\n            </button>\n        );\n    }\n}\n\nexport default Button;\n","import React from \"react\";\nimport Board from \"./Board\";\nimport AI from \"./AI\";\nimport BoardHelpers from \"./BoardHelpers\";\nimport { SettingsInterface, Symbols } from \"../general_components/Types\";\nimport Button from \"../general_components/Button\";\n\ninterface Props {\n    settings: SettingsInterface;\n}\n\ninterface State {\n    winner: string | null;\n    isP1sTurn: boolean;\n    symbols: Symbols;\n    isFinished: boolean;\n    squares: string[][];\n    AiEmotion: string | null;\n}\n\nclass Game extends React.Component<Props, State> {\n    constructor(props: Readonly<Props>) {\n        super(props);\n        this.state = {\n            isP1sTurn:\n                props.settings[\"whoIsMovingFirst\"] === \"rnd\"\n                    ? Math.random() >= 0.5\n                    : props.settings[\"whoIsMovingFirst\"] === \"ply1\",\n            symbols: {\n                ply1: props.settings[\"whoIsO\"] === \"ply1\" ? \"O\" : \"X\",\n                ply2: props.settings[\"whoIsO\"] === \"ply1\" ? \"X\" : \"O\",\n            },\n            isFinished: false,\n            squares: Array(3).fill(Array(3).fill(null)),\n            // squares: [\n            //     [\"O\", null, \"X\"],\n            //     [\"X\", null, null],\n            //     [\"X\", \"O\", \"O\"],\n            // ],\n            winner: null,\n            AiEmotion: null,\n        };\n    }\n\n    render() {\n        return (\n            <div>\n                <h2>\n                    {this.state.winner === \"Draw\"\n                        ? \"Draw!\"\n                        : this.state.winner\n                        ? `${this.state.winner} wins!`\n                        : \"\"}\n                </h2>\n                <Board\n                    squares={this.state.squares}\n                    handleClick={this.handleClick}\n                />\n                <p>\n                    Current turn:{\" \"}\n                    {this.state.isP1sTurn ? \"Player 1\" : \"Player 2\"} (\n                    {this.state.symbols[this.state.isP1sTurn ? \"ply1\" : \"ply2\"]}\n                    )\n                </p>\n                <Button\n                    color=\"orange\"\n                    handleClick={() => {\n                        this.reset();\n                    }}\n                >\n                    Reset Board\n                </Button>\n                {this.props.settings[\"playerTwoMode\"] !== \"hum\" ? (\n                    <p>AI: {this.state.AiEmotion || \"„Ñü( ‚ñî, ‚ñî )„Ñè\"}</p>\n                ) : (\n                    \"\"\n                )}\n            </div>\n        );\n    }\n\n    componentDidMount() {\n        this.AiTurnCheck();\n        this.updateAiEmotion();\n    }\n\n    componentDidUpdate() {\n        this.AiTurnCheck();\n        this.updateAiEmotion();\n    }\n\n    AiTurnCheck = () => {\n        // Make sure we're still playing\n        if (!this.state.isFinished) {\n            // Check if either playing is winning\n            let winner = BoardHelpers.evaluateSquares(\n                this.state.squares,\n                this.state.symbols\n            );\n            if (winner) {\n                this.setState({\n                    isFinished: true,\n                    winner: winner,\n                });\n                return;\n            }\n            // Make sure it isn't a draw\n            if (BoardHelpers.getBlankSquares(this.state.squares).length === 0) {\n                this.setState({\n                    isFinished: true,\n                    winner: \"Draw\",\n                });\n                return;\n            }\n            this.makeAiMove();\n        }\n    };\n\n    updateAiEmotion = () => {\n        // Make sure AI is used\n        if (this.props.settings[\"playerTwoMode\"] === \"hum\") {\n            return;\n        }\n        let emotion = AI.getEmotion(\n            this.state.squares,\n            this.props.settings[\"playerTwoMode\"],\n            this.state.isP1sTurn ? \"ply1\" : \"ply2\",\n            this.state.symbols\n        );\n        if (this.state.AiEmotion === emotion) {\n            return;\n        }\n        this.setState({\n            AiEmotion: emotion,\n        });\n    };\n\n    makeAiMove = () => {\n        if (\n            !this.state.isP1sTurn &&\n            this.props.settings[\"playerTwoMode\"] !== \"hum\"\n        ) {\n            this.setState((prevState) => {\n                let comMove = AI.getMove(\n                    this.state.squares,\n                    this.props.settings[\"playerTwoMode\"],\n                    this.state.symbols\n                );\n                let newSquares = BoardHelpers.copyWithMove(\n                    this.state.squares,\n                    this.state.symbols[\"ply2\"],\n                    comMove\n                );\n                let newState = {\n                    ...prevState,\n                    squares: newSquares,\n                    isP1sTurn: true,\n                };\n                return newState;\n            });\n        }\n    };\n\n    reset = () => {\n        this.setState({\n            AiEmotion: null,\n            isFinished: false,\n            isP1sTurn:\n                this.props.settings[\"whoIsMovingFirst\"] === \"rnd\"\n                    ? Math.random() >= 0.5\n                    : this.props.settings[\"whoIsMovingFirst\"] === \"ply1\",\n            squares: Array(3).fill(Array(3).fill(null)),\n            symbols: {\n                ply1: this.props.settings[\"whoIsO\"] === \"ply1\" ? \"O\" : \"X\",\n                ply2: this.props.settings[\"whoIsO\"] === \"ply1\" ? \"X\" : \"O\",\n            },\n            winner: null,\n        });\n    };\n\n    handleClick = (rowIndex: number, cellIndex: number) => {\n        // Make sure we're still going\n        if (this.state.isFinished) {\n            return;\n        }\n        // Make sure square is empty\n        if (this.state.squares[rowIndex][cellIndex]) {\n            return;\n        }\n        // Make sure the com isn't thinking\n        if (\n            !this.state.isP1sTurn &&\n            this.props.settings[\"playerTwoMode\"] !== \"hum\"\n        ) {\n            return;\n        }\n        // Human moving\n        let squares = BoardHelpers.copyWithMove(this.state.squares);\n        squares[rowIndex][cellIndex] = this.state.symbols[\n            this.state.isP1sTurn ? \"ply1\" : \"ply2\"\n        ];\n        this.setState({\n            squares: squares,\n            isP1sTurn: !this.state.isP1sTurn,\n        });\n    };\n}\n\nexport default Game;\n","import React from \"react\";\n\ninterface Props {\n    label: string;\n    id: string;\n}\ninterface State {}\n\nclass ButtonGroup extends React.Component<Props, State> {\n    render() {\n        return (\n            <div className=\"button-group\">\n                <label htmlFor={this.props.id}>{this.props.label}</label>\n                <div id={this.props.id}>{this.props.children}</div>\n            </div>\n        );\n    }\n}\n\nexport default ButtonGroup;\n","import React from \"react\";\nimport { SettingsInterface } from \"../general_components/Types\";\nimport ButtonGroup from \"./ButtonGroup\";\nimport Button from \"../general_components/Button\";\n\ninterface SettingsButtonGroupsInterface {\n    [buttonGroupId: string]: {\n        labelText: string;\n        buttons: {\n            [buttonId: string]: {\n                isSelected: boolean;\n                text: string;\n            };\n        };\n    };\n}\n\ninterface Props {\n    submitWithSettings: (settings: SettingsInterface) => void;\n}\ninterface State {\n    buttonGroups: SettingsButtonGroupsInterface;\n}\n\nclass Settings extends React.Component<Props, State> {\n    DEFAULT_SETTINGS: { [id: string]: string } = {}; // Defaults to every first option\n\n    constructor(props: Readonly<Props>) {\n        super(props);\n        this.state = {\n            buttonGroups: {\n                whoIsO: {\n                    labelText: \"Who is O?\",\n                    buttons: {\n                        ply1: {\n                            isSelected: false,\n                            text: \"Player 1\",\n                        },\n                        ply2: {\n                            isSelected: false,\n                            text: \"Player 2\",\n                        },\n                    },\n                },\n                whoIsMovingFirst: {\n                    labelText: \"Who is moving first?\",\n                    buttons: {\n                        rnd: {\n                            isSelected: false,\n                            text: \"Random\",\n                        },\n                        ply1: {\n                            isSelected: false,\n                            text: \"Player 1\",\n                        },\n                        ply2: {\n                            isSelected: false,\n                            text: \"Player 2\",\n                        },\n                    },\n                },\n                playerTwoMode: {\n                    labelText: \"Player Two is:\",\n                    buttons: {\n                        esy: {\n                            isSelected: false,\n                            text: \"Easy Computer\",\n                        },\n                        med: {\n                            isSelected: false,\n                            text: \"Medium Computer\",\n                        },\n                        imp: {\n                            isSelected: false,\n                            text: \"Impossible Computer\",\n                        },\n                        hum: {\n                            isSelected: false,\n                            text: \"Human\",\n                        },\n                    },\n                },\n            },\n        };\n    }\n\n    componentDidMount() {\n        this.selectDefaultSettings();\n    }\n\n    selectDefaultSettings = () => {\n        this.setState((oldState: Readonly<State>) => {\n            let newState = { ...oldState };\n            Object.entries(this.DEFAULT_SETTINGS).forEach(\n                ([settingId, defaultSetting]) => {\n                    if (newState.buttonGroups[settingId] === undefined) {\n                        console.log(\"Error\");\n                        return;\n                    }\n                    newState.buttonGroups[settingId].buttons[\n                        defaultSetting\n                    ].isSelected = true;\n                }\n            );\n            Object.keys(oldState.buttonGroups).forEach((settingId) => {\n                newState.buttonGroups[settingId].buttons[\n                    this.DEFAULT_SETTINGS[settingId] ||\n                        Object.keys(newState.buttonGroups[settingId].buttons)[0]\n                ].isSelected = true;\n            });\n            return newState;\n        });\n    };\n\n    render() {\n        return (\n            <div className=\"settings\">\n                <h2>Settings</h2>\n                {/* Button groups */}\n                {this.getButtonGroups()}\n\n                {/* Play button */}\n                <Button\n                    handleClick={() => {\n                        this.submit();\n                    }}\n                    color=\"filled-green\"\n                    largeButton={true}\n                >\n                    Play!\n                </Button>\n            </div>\n        );\n    }\n\n    submit = () => {\n        let toSubmit: { [index: string]: string | undefined } = {};\n        Object.entries(this.state.buttonGroups).forEach(\n            ([settingId, settingData]) => {\n                let selectedOption = Object.keys(settingData.buttons).find(\n                    (buttonId) => settingData.buttons[buttonId].isSelected\n                );\n                toSubmit[settingId || \"Error\"] = selectedOption;\n            }\n        );\n        this.props.submitWithSettings(toSubmit);\n    };\n\n    getButtonGroups = () => {\n        return (\n            <div className=\"button-groups\">\n                {Object.entries(this.state.buttonGroups).map(\n                    ([buttonGroupId, buttonGroupData], index) => {\n                        return (\n                            <ButtonGroup\n                                id={buttonGroupId}\n                                label={buttonGroupData.labelText}\n                                key={index}\n                            >\n                                {Object.entries(buttonGroupData.buttons).map(\n                                    ([buttonId, buttonData], index) => {\n                                        return (\n                                            <Button\n                                                handleClick={() => {\n                                                    this.logSelect(\n                                                        buttonGroupId,\n                                                        buttonId\n                                                    );\n                                                }}\n                                                color={\n                                                    buttonData.isSelected\n                                                        ? \"filled-purple\"\n                                                        : \"gray\"\n                                                }\n                                                key={index}\n                                                staticOnHover={\n                                                    buttonData.isSelected\n                                                }\n                                            >\n                                                {buttonData.text}\n                                            </Button>\n                                        );\n                                    }\n                                )}\n                            </ButtonGroup>\n                        );\n                    }\n                )}\n            </div>\n        );\n    };\n\n    logSelect = (settingId: string, toSetTo: string) => {\n        this.setState((oldState) => {\n            let newState = { ...oldState };\n            Object.entries(newState.buttonGroups[settingId].buttons).forEach(\n                ([id, data]) => {\n                    data.isSelected = false;\n                }\n            );\n            newState.buttonGroups[settingId].buttons[toSetTo].isSelected = true;\n            return newState;\n        });\n    };\n}\n\nexport default Settings;\n","import React from \"react\";\nimport FakeTypedHeader from \"./general_components/FakeTypedHeader\";\nimport Game from \"./game_components/Game\";\nimport Options from \"./settings_components/Settings\";\nimport { SettingsInterface } from \"./general_components/Types\";\nimport Button from \"./general_components/Button\";\n\ntype PossibleColorMode = \"light\" | \"dark\";\n\ninterface State {\n    showSettings: boolean;\n    showGame: boolean;\n    settings: SettingsInterface;\n    colorMode: PossibleColorMode;\n}\n\nclass Window extends React.Component<{}, State> {\n    constructor(props: Readonly<{}>) {\n        super(props);\n\n        // @ts-ignore: Type 'string' is not assignable to type '\"light\" | \"dark\"'\n        let cM: PossibleColorMode = localStorage.getItem(\"colorMode\");\n        if (!cM) {\n            localStorage.setItem(\"colorMode\", \"light\");\n            cM = \"light\";\n        }\n\n        this.state = {\n            showSettings: true,\n            showGame: false,\n            settings: {\n                whoIsO: null,\n                whoIsMovingFirst: null,\n                playerTwoMode: null,\n            },\n            colorMode: cM,\n        };\n    }\n\n    render() {\n        return (\n            <div className={`window ${this.state.colorMode}`}>\n                <FakeTypedHeader content=\"tic tac toe\" />\n                <hr className=\"divider\" />\n                {this.state.showSettings && (\n                    <Options submitWithSettings={this.submitWithOptions} />\n                )}\n                {this.state.showGame && <Game settings={this.state.settings} />}\n                <Button\n                    color={\n                        this.state.colorMode === \"light\"\n                            ? \"filled-dark\"\n                            : \"filled-light\"\n                    }\n                    handleClick={() => {\n                        this.toggleDarkMode();\n                    }}\n                    position=\"br\"\n                >\n                    Dark Mode!{\" \"}\n                    <span role=\"img\" aria-label=\"emoji\">\n                        üòé\n                    </span>\n                </Button>\n            </div>\n        );\n    }\n\n    componentDidUpdate() {\n        // Update localstorage colorMode if needed\n        localStorage.setItem(\"colorMode\", this.state.colorMode);\n    }\n\n    toggleDarkMode = () => {\n        let nextColorMode: PossibleColorMode =\n            this.state.colorMode === \"light\" ? \"dark\" : \"light\";\n        this.setState({\n            colorMode: nextColorMode,\n        });\n    };\n\n    submitWithOptions = (settings: SettingsInterface) => {\n        this.setState({\n            showSettings: false,\n            showGame: true,\n            settings: settings,\n        });\n    };\n}\n\nexport default Window;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport Window from \"./components/Window\";\n\nimport \"./scss/index.scss\";\n\nReactDOM.render(<Window />, document.getElementById(\"root\"));\n"],"sourceRoot":""}